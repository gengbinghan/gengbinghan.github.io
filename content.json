[{"title":"对人工智能的一点看法","date":"2017-02-06T12:06:51.000Z","path":"2017/02/06/对人工智能的一点看法/","text":"下午茶时间在公司附近超市闲逛，发现这家超市多了几台自助收银机，顾客买了商品后，用机器自助扫描，自助付款，全程没有收银员参与，这让我想起一年前去中国银行办卡，第一次用到的自助办卡机，有了这个机器，顾客不用和柜员直接面对面了，但仍需要柜员，只不过柜员在机器的那头远程为顾客办理业务，这样的办公模式大大提高了银行的服务效率！也许再过一段时间，银行将不需要柜员，纯机器就可以办理业务，这也意味着必将有一批银行柜员和超市收银员失业或转岗…… 进入16年，人工智能越来越多的进入到普通人的生活中，从智能家居到可穿戴设备再到自动驾驶，从AlphaGo战胜李世石开始，各大科技巨头就纷纷开始布局人工智能，富士康已经用大量机器人代替了数万名流水线工人……不少行业大佬预计2017年将是人工智能飞速发展的一年，作为一名移动端开发程序员，面对人工智能，我是有些恐慌的，既然司机和律师这样专业性较强的职业都会被人工智能取代，那么部分程序员也必将被人工智能取代，随着小程序和混合开发的出现，彻底的原生app越来越少，也许很快人工智能就能自己开发app了，初级程序员会像部分收银员和银行柜员一样，要么失业要么转岗，但是话说回来，作为一名程序员，如果没有基本的独立思考能力和自学能力，不管在何时都很难赶上科技发展的浪潮，最终被拍死在沙滩上…… 最近网上不少大咖推荐《未来简史》这本书，据说是本非常开脑洞的书，为了对未来有更好的准备，或许该买来看看！未来已经到来，人工智能只是导火索，只有活在未来的人很难被淘汰，所以要努力成为一个活在未来的人！","tags":[{"name":"随笔","slug":"随笔","permalink":"http://binngirl.com/tags/随笔/"}]},{"title":"git使用简单总结","date":"2017-01-16T15:07:02.000Z","path":"2017/01/16/git使用简单总结/","text":"几个概念： 工作区：仓库文件夹里除.git目录以外的内容 版本库：.git目录，用于存储记录版本信息 暂缓区（stage） 分支（master）：git自动创建的第一个分支 HEAD指针：用于指向当前分支 注：显示隐藏文件命令： defaults write com.apple.finder AppleShowAllFiles -bool true(false) 一、个人演练（命令行演练） 进入到工作目录中，初始化一个代码仓库：git init 给该git仓库配置一个用户名和邮箱：git config user.name “gengbinghan”git config user.email “9777@qq.com” 初始化代码：touch main.m -&gt; git status -&gt; Untracked files:（红色文件）：新添加或者新修改的文件在工作区中，没有被添加到暂缓区中git add main.m -&gt; git status -&gt; Changes to be committed:（绿色文件） :将工作区的代码已经添加到暂缓区，可以提交到代码仓库中了 查看文件的状态：git status Untracked files:(红色文件)：新添加或者新修改的文件在工作区中，没有被添加到暂缓区中 Changes to be committed:（绿色文件） :将工作区的代码已经添加到暂缓区，可以提交到代码仓库中了 git commit -m “xxxx”（提交代码）[master (root-commit) 949712f] 初始化项目1 file changed, 0 insertions(+), 0 deletions(-)create mode 100644 main.m 修改文件：open main.m git add .将工作区所有的文件添加到暂缓区里面 给git命令其别名:git config alias.要起的别名 “要给谁其别名”例: git config alias.ci “commit -m” 查看历史版本git loggit 版本号：61d5d0c23e7e1b772c32829ed2feb130728fae66 git版本号是由sha1加密算法生成的一个40位的哈希值git reflog 版本回退git reset –hard HEAD：回退当前版本（当前版本未提交）git reset –hard 版本号 –global的作用（配置全局的用户名和密码，其他地方可以不配置） git config –global user.name “gengbinghan” git config –glabal user.email “9777@qq.com” 二、团队开发（共享版本库）文件夹/U盘/Github/oschina 创建一个代码共享库（让一个文件夹成为共享库）git init – bare 经理将我们的共享代码仓库中的内容clone下来git clone 地址 项目经理初始化项目 忽略文件：在我们的.git 同级目录下创建一个.gitignore文件，在该文件中指定需要忽略的文件 github上搜索：.gitignore -&gt; 打开ObjectiveC -&gt; 复制文件内容到新建的.ignore文件中(https://github.com/github/gitignore/blob/master/Objective-C.gitignore) git add . -&gt; git commit –m “注释”，将.gitignore添加到本地仓库管理中 OSChina和Github的使用","tags":[{"name":"iOS学习","slug":"iOS学习","permalink":"http://binngirl.com/tags/iOS学习/"}]},{"title":"运动给我势能","date":"2017-01-11T14:49:11.000Z","path":"2017/01/11/运动给我势能/","text":"坚持慢跑和健身有一段时间了，16年中旬开始用keep健身，中间跳了几周insanity（太伤膝盖，已放弃），年底开始用咕咚跑步，下面两张图是目前为止我的运动数据： 在日常生活中也不难发现，长期运动的人精神面貌会比不爱运动的人更好，有一种健康的，朝气蓬勃气质（看下宁泽涛、孙杨就知道），虽然持续运动的时间不算长，但我已切身感受到运动给我的生活带来了改变：敲代码更加专注了，工作效率更高了，负面情绪变少了，气色变好了……于是，对大部分人来说痛苦的运动逐渐变成了我的每日刚需……当然，运动带给我更多的是一种势能，不管是慢跑还是有氧健身，每次运动结束，都会觉得浑身充满力量，生活变得更有动力，态度也更加积极，以至于每次跑步都停不下来，甚至到了不运动不舒服地步……我会持续运动下去，没有终点！","tags":[{"name":"随笔","slug":"随笔","permalink":"http://binngirl.com/tags/随笔/"}]},{"title":"关于GCD","date":"2017-01-10T14:44:54.000Z","path":"2017/01/10/关于GCD/","text":"1.GCD基本知识01.两个核心概念——队列和任务 任务：执行什么操作队列：用来存放任务 02.同步函数和异步函数 2.GCD基本使用GCD的使用就两个步骤：定制任务确定想做的事、将任务添加到队列中： 1.GCD会自动将队列中的任务取出，放到对应的线程中执行2.任务的取出遵循队列的FIFO原则：先进先出，后进后出 01.异步函数+并发队列：开启多条线程，并发执行任务 02.异步函数+串行对列：开启一条线程，串行执行任务 03.同步函数+并发队列：不开线程，并发执行任务 04.同步函数+串行对列：不开线程，串行执行任务 05.异步函数+主队列：不开线程，在主队列中串行执行任务 06.同步函数+主队列：不开线程，串行执行任务（注意死锁发生） 07.注意同步函数和异步函数在执行顺序上的差异 3.GCD线程间通信123456789101112131415161718192021//0.获取一个全局的队列 dispatch_queue_t queue = dispatch_get_global_queue(0, 0); //1.先开启一个线程，把下载图片的操作放在子线程中处理 dispatch_async(queue, ^&#123; //2.下载图片 NSURL *url = [NSURL URLWithString:@&quot;http://h.hiphotos.baidu.com/zhidao/pic/item/6a63f6246b600c3320b14bb3184c510fd8f9a185.jpg&quot;]; NSData *data = [NSData dataWithContentsOfURL:url]; UIImage *image = [UIImage imageWithData:data]; NSLog(@&quot;下载操作所在的线程--%@&quot;,[NSThread currentThread]); //3.回到主线程刷新UI dispatch_async(dispatch_get_main_queue(), ^&#123; self.imageView.image = image; //打印查看当前线程 NSLog(@&quot;刷新UI---%@&quot;,[NSThread currentThread]); &#125;); &#125;); 4.GCD其他常用函数12345678910111213141516171819202122232425262728293031323334353601 栅栏函数（控制任务的执行顺序） dispatch_barrier_async(queue, ^&#123; NSLog(@&quot;--dispatch_barrier_async-&quot;); &#125;); 02 延迟执行（延迟·控制在哪个线程执行） dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; NSLog(@&quot;---%@&quot;,[NSThread currentThread]); &#125;); 03 一次性代码（注意不能放到懒加载） -(void)once &#123; //整个程序运行过程中只会执行一次 //onceToken用来记录该部分的代码是否被执行过 static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; NSLog(@&quot;-----&quot;); &#125;); &#125; 04 快速迭代（开多个线程并发完成迭代操作） dispatch_apply(subpaths.count, queue, ^(size_t index) &#123; &#125;); 05 队列组（同栅栏函数） //创建队列组 dispatch_group_t group = dispatch_group_create(); //队列组中的任务执行完毕之后，执行该函数 dispatch_group_notify(dispatch_group_t group,dispatch_queue_t queue,dispatch_block_t block); 06进入群组和离开群组 dispatch_group_enter(group);//执行该函数后，后面异步执行的block会被gruop监听 dispatch_group_leave(group);//异步block中，所有的任务都执行完毕，最后离开群组 //注意：dispatch_group_enter|dispatch_group_leave必须成对使用 5.容易混淆的术语有四个术语容易混淆：同步、异步、并发、串行 同步和异步主要影响：能不能开启新的线程 同步：只是在当前线程中执行任务，不具备开启新线程的能力 异步：可以在新的线程中执行任务，具备开启新线程的能力 并发和串行主要影响：任务的执行方式 并发：允许多个任务并发（同时）执行 串行：一个任务执行完毕后，在执行下一个任务","tags":[{"name":"iOS学习","slug":"iOS学习","permalink":"http://binngirl.com/tags/iOS学习/"}]},{"title":"Modal","date":"2016-06-06T14:06:29.000Z","path":"2016/06/06/Modal/","text":"","tags":[{"name":"iOS学习","slug":"iOS学习","permalink":"http://binngirl.com/tags/iOS学习/"}]},{"title":"FMDB","date":"2016-06-02T14:04:52.000Z","path":"2016/06/02/FMDB/","text":"","tags":[{"name":"iOS学习","slug":"iOS学习","permalink":"http://binngirl.com/tags/iOS学习/"}]},{"title":"加密概述","date":"2016-05-13T14:04:17.000Z","path":"2016/05/13/加密概述/","text":"","tags":[{"name":"iOS学习","slug":"iOS学习","permalink":"http://binngirl.com/tags/iOS学习/"}]},{"title":"关于MD5","date":"2016-04-10T14:03:53.000Z","path":"2016/04/10/关于MD5/","text":"什么是MD5? MD5全称是Message Digest Algorithm 5，译为“消息摘要算法第5版” 效果：对输入信息生成唯一的128位散列值（32个字符） MD5的特点： 输入两个不同的明文不会得到相同的输出值 根据输出值，不能得到原始的明文，即其过程不可逆 MD5改进： 加盐（Salt）：在明文的固定位置插入随机串，然后再进行MD5。 先加密，后乱序：先对明文进行MD5，然后对加密得到的MD5串的字符进行乱序。 栗子： 导入NSString+hash.h封装好的加密分类算法下面是封装好的demo： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#import &quot;ViewController.h&quot;#import &quot;NSString+Hash.h&quot;@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; [self MD5]; [self MD5Salt:@&quot;san&quot;]; [self doubleMD5]; [self MD5Reorder];&#125;//MD5加密-(void)MD5&#123; NSString *pwd = @&quot;123456&quot;; NSString *pwdMD5 = [pwd md5String]; NSLog(@&quot;%@&quot;,pwdMD5);&#125;/** * 撒盐 加密 MD5($pass.$salt) */-(void)MD5Salt:(NSString *)salt&#123; NSString *pwd = @&quot;123456&quot;; pwd =[pwd stringByAppendingString:salt]; 撒盐：随机地往明文中插入任意字符串 NSString *pwdMD5 = [pwd md5String]; NSLog(@&quot;%@&quot;,pwdMD5);&#125;/** * MD5(MD5($pass)) */- (void)doubleMD5&#123; NSString *pwd = @&quot;123456&quot;; NSString *pwdMD5MD5 = [[pwd md5String]md5String]; NSLog(@&quot;%@&quot;,pwdMD5MD5);&#125;/** * 先加密，后乱序 */- (void)MD5Reorder&#123; NSString *pwd = @&quot;123456&quot;; NSString *pwdMD5 = [pwd md5String]; NSLog(@&quot;oldpwdMD5=%@&quot;,pwdMD5); NSString *prefix = [pwdMD5 substringFromIndex:3]; 从下标为3的开始截取（包含3） NSString *subfix = [pwdMD5 substringToIndex:3]; 截取0到3的字符串（不包含3） pwdMD5 = [prefix stringByAppendingString:subfix]; NSLog(@&quot;newpwdMD5=%@&quot;,pwdMD5);&#125;@end","tags":[{"name":"iOS学习","slug":"iOS学习","permalink":"http://binngirl.com/tags/iOS学习/"}]},{"title":"内存管理","date":"2016-03-23T14:07:25.000Z","path":"2016/03/23/内存管理/","text":"","tags":[{"name":"iOS学习","slug":"iOS学习","permalink":"http://binngirl.com/tags/iOS学习/"}]},{"title":"KVC/KVO","date":"2016-01-20T14:19:20.000Z","path":"2016/01/20/KVC-KVO/","text":"","tags":[{"name":"iOS学习","slug":"iOS学习","permalink":"http://binngirl.com/tags/iOS学习/"}]}]