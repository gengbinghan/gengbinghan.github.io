[{"title":"初识热更新","date":"2017-02-21T07:17:02.000Z","path":"2017/02/21/初识热更新/","text":"每次提交版本都得等待一周到两周的审核时间，我是受不了这种速度了，于是决定研究有没有其他的方法跳过提交版本这个步骤，同样能够修复bug呢，于是找到了JSPatch，也许也有很多人觉得这是个很高大上的技术，其实不然，我们只需要在项目里引入极小的引擎文件，就可以使用 JavaScript 调用任何 Objective-C 的原生接口，替换任意 Objective-C 原生方法。当然呢，目前主要用于下发 JS 脚本替换原生 Objective-C 代码，实时修复线上 bug。 首先说一下JSPatch实现的内部原理：JsPatch能做到通过JS调用和改写OC方法最根本的原因是 Objective-C 是动态语言，OC上所有方法的调用、类的生成都通过 Objective-C Runtime 在运行时进行，我们可以通过类名和方法名反射得到相应的类和方法，也可以替换某个类的方法为新的实现，还可以新注册一个类，为类添加方法。所以 JSPatch 的原理就是：JS传递字符串给OC，OC通过 Runtime 接口调用和替换OC方法。这个很容易理解，JS的作用只是一个信使的作用，具体实现还是得靠我们OC,所以说OC还是世界上最美的语言，哈哈。 同时在这里介绍一个比较好的网站 点这里.这是一个OC转JS的一个工具网站。 下面演示一下具体实现的步骤 123456789101112131415161718192021222324252627282930313233343536- (void)viewDidLoad&#123; UITableView* tv = [[UITableView alloc]initWithFrame:self.view.bounds style:UITableViewStylePlain]; self.mqTableView = tv; self.mqTableView.delegate = self; self.mqTableView.dataSource = self; [self.view addSubview:self.mqTableView];&#125;#pragma mark -- UITableViewDataSource- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section&#123; return 3;&#125;- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; static NSString* i= @&quot;cell&quot;; UITableViewCell* cell = [tableView dequeueReusableCellWithIdentifier:i]; if (cell == nil ) &#123; cell =[[UITableViewCell alloc]initWithStyle:UITableViewCellStyleDefault reuseIdentifier:i]; &#125; cell.textLabel.text = @&quot;meiqing&quot;; cell.backgroundColor = [UIColor whiteColor]; return cell;&#125;- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath&#123; self.dataSource = @[@&quot;1&quot;,@&quot;2&quot;]; 肯定会超出数组范围导致 crash NSString *content = self.dataSource[indexPath.row];&#125; 显示的结果是这样的上面的图片是没有修改时候的显示，当我点击第三行一定会闪退，怎么修复呢？这个时候就不用发版本了，服务器可以给我们传送一个js文件，文件里的内容是这样的：同时，我们在APPDelegate里调用这个JS就可以了，如下：再次运行就不会出现闪退了。","tags":[{"name":"iOS学习","slug":"iOS学习","permalink":"http://binngirl.com/tags/iOS学习/"}]},{"title":"对人工智能的一点看法","date":"2017-02-06T12:06:51.000Z","path":"2017/02/06/对人工智能的一点看法/","text":"下午茶时间在公司附近超市闲逛，发现这家超市多了几台自助收银机，顾客买了商品后，用机器自助扫描，自助付款，全程没有收银员参与，这让我想起一年前去中国银行办卡，第一次用到的自助办卡机，有了这个机器，顾客不用和柜员直接面对面了，但仍需要柜员，只不过柜员在机器的那头远程为顾客办理业务，这样的办公模式大大提高了银行的服务效率！也许再过一段时间，银行将不需要柜员，纯机器就可以办理业务，这也意味着必将有一批银行柜员和超市收银员失业或转岗…… 进入16年，人工智能越来越多的进入到普通人的生活中，从智能家居到可穿戴设备再到自动驾驶，从AlphaGo战胜李世石开始，各大科技巨头就纷纷开始布局人工智能，富士康已经用大量机器人代替了数万名流水线工人……不少行业大佬预计2017年将是人工智能飞速发展的一年，作为一名移动端开发程序员，面对人工智能，我是有些恐慌的，既然司机和律师这样专业性较强的职业都会被人工智能取代，那么部分程序员也必将被人工智能取代，随着小程序和混合开发的出现，彻底的原生app越来越少，也许很快人工智能就能自己开发app了，初级程序员会像部分收银员和银行柜员一样，要么失业要么转岗，但是话说回来，作为一名程序员，如果没有基本的独立思考能力和自学能力，不管在何时都很难赶上科技发展的浪潮，最终被拍死在沙滩上…… 最近网上不少大咖推荐《未来简史》这本书，据说是本非常开脑洞的书，为了对未来有更好的准备，或许该买来看看！未来已经到来，人工智能只是导火索，只有活在未来的人很难被淘汰，所以要努力成为一个活在未来的人！","tags":[{"name":"随笔","slug":"随笔","permalink":"http://binngirl.com/tags/随笔/"}]},{"title":"git使用简单总结","date":"2017-01-16T15:07:02.000Z","path":"2017/01/16/git使用简单总结/","text":"几个概念： 工作区：仓库文件夹里除.git目录以外的内容 版本库：.git目录，用于存储记录版本信息 暂缓区（stage） 分支（master）：git自动创建的第一个分支 HEAD指针：用于指向当前分支 注：显示隐藏文件命令： defaults write com.apple.finder AppleShowAllFiles -bool true(false) 一、个人演练（命令行演练） 进入到工作目录中，初始化一个代码仓库：git init 给该git仓库配置一个用户名和邮箱：git config user.name “gengbinghan”git config user.email “9777@qq.com” 初始化代码：touch main.m -&gt; git status -&gt; Untracked files:（红色文件）：新添加或者新修改的文件在工作区中，没有被添加到暂缓区中git add main.m -&gt; git status -&gt; Changes to be committed:（绿色文件） :将工作区的代码已经添加到暂缓区，可以提交到代码仓库中了 查看文件的状态：git status Untracked files:(红色文件)：新添加或者新修改的文件在工作区中，没有被添加到暂缓区中 Changes to be committed:（绿色文件） :将工作区的代码已经添加到暂缓区，可以提交到代码仓库中了 git commit -m “xxxx”（提交代码）[master (root-commit) 949712f] 初始化项目1 file changed, 0 insertions(+), 0 deletions(-)create mode 100644 main.m 修改文件：open main.m git add .将工作区所有的文件添加到暂缓区里面 给git命令其别名:git config alias.要起的别名 “要给谁其别名”例: git config alias.ci “commit -m” 查看历史版本git loggit 版本号：61d5d0c23e7e1b772c32829ed2feb130728fae66 git版本号是由sha1加密算法生成的一个40位的哈希值git reflog 版本回退git reset –hard HEAD：回退当前版本（当前版本未提交）git reset –hard 版本号 –global的作用（配置全局的用户名和密码，其他地方可以不配置） git config –global user.name “gengbinghan” git config –glabal user.email “9777@qq.com” 二、团队开发（共享版本库）文件夹/U盘/Github/oschina 创建一个代码共享库（让一个文件夹成为共享库）git init – bare 经理将我们的共享代码仓库中的内容clone下来git clone 地址 项目经理初始化项目 忽略文件：在我们的.git 同级目录下创建一个.gitignore文件，在该文件中指定需要忽略的文件 github上搜索：.gitignore -&gt; 打开ObjectiveC -&gt; 复制文件内容到新建的.ignore文件中(https://github.com/github/gitignore/blob/master/Objective-C.gitignore) git add . -&gt; git commit –m “注释”，将.gitignore添加到本地仓库管理中 OSChina和Github的使用","tags":[{"name":"iOS学习","slug":"iOS学习","permalink":"http://binngirl.com/tags/iOS学习/"}]},{"title":"运动给我势能","date":"2017-01-11T14:49:11.000Z","path":"2017/01/11/运动给我势能/","text":"坚持慢跑和健身有一段时间了，16年中旬开始用keep健身，中间跳了几周insanity（太伤膝盖，已放弃），年底开始用咕咚跑步，下面两张图是目前为止我的运动数据： 在日常生活中也不难发现，长期运动的人精神面貌会比不爱运动的人更好，有一种健康的，朝气蓬勃气质（看下宁泽涛、孙杨就知道），虽然持续运动的时间不算长，但我已切身感受到运动给我的生活带来了改变：敲代码更加专注了，工作效率更高了，负面情绪变少了，气色变好了……于是，对大部分人来说痛苦的运动逐渐变成了我的每日刚需……当然，运动带给我更多的是一种势能，不管是慢跑还是有氧健身，每次运动结束，都会觉得浑身充满力量，生活变得更有动力，态度也更加积极，以至于每次跑步都停不下来，甚至到了不运动不舒服地步……我会持续运动下去，没有终点！","tags":[{"name":"随笔","slug":"随笔","permalink":"http://binngirl.com/tags/随笔/"}]},{"title":"关于GCD","date":"2017-01-10T14:44:54.000Z","path":"2017/01/10/关于GCD/","text":"1.GCD基本知识01.两个核心概念——队列和任务 任务：执行什么操作队列：用来存放任务 02.同步函数和异步函数 2.GCD基本使用GCD的使用就两个步骤：定制任务确定想做的事、将任务添加到队列中： 1.GCD会自动将队列中的任务取出，放到对应的线程中执行2.任务的取出遵循队列的FIFO原则：先进先出，后进后出 01.异步函数+并发队列：开启多条线程，并发执行任务 02.异步函数+串行对列：开启一条线程，串行执行任务 03.同步函数+并发队列：不开线程，并发执行任务 04.同步函数+串行对列：不开线程，串行执行任务 05.异步函数+主队列：不开线程，在主队列中串行执行任务 06.同步函数+主队列：不开线程，串行执行任务（注意死锁发生） 07.注意同步函数和异步函数在执行顺序上的差异 3.GCD线程间通信123456789101112131415161718192021//0.获取一个全局的队列 dispatch_queue_t queue = dispatch_get_global_queue(0, 0); //1.先开启一个线程，把下载图片的操作放在子线程中处理 dispatch_async(queue, ^&#123; //2.下载图片 NSURL *url = [NSURL URLWithString:@&quot;http://h.hiphotos.baidu.com/zhidao/pic/item/6a63f6246b600c3320b14bb3184c510fd8f9a185.jpg&quot;]; NSData *data = [NSData dataWithContentsOfURL:url]; UIImage *image = [UIImage imageWithData:data]; NSLog(@&quot;下载操作所在的线程--%@&quot;,[NSThread currentThread]); //3.回到主线程刷新UI dispatch_async(dispatch_get_main_queue(), ^&#123; self.imageView.image = image; //打印查看当前线程 NSLog(@&quot;刷新UI---%@&quot;,[NSThread currentThread]); &#125;); &#125;); 4.GCD其他常用函数12345678910111213141516171819202122232425262728293031323334353601 栅栏函数（控制任务的执行顺序） dispatch_barrier_async(queue, ^&#123; NSLog(@&quot;--dispatch_barrier_async-&quot;); &#125;); 02 延迟执行（延迟·控制在哪个线程执行） dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; NSLog(@&quot;---%@&quot;,[NSThread currentThread]); &#125;); 03 一次性代码（注意不能放到懒加载） -(void)once &#123; //整个程序运行过程中只会执行一次 //onceToken用来记录该部分的代码是否被执行过 static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; NSLog(@&quot;-----&quot;); &#125;); &#125; 04 快速迭代（开多个线程并发完成迭代操作） dispatch_apply(subpaths.count, queue, ^(size_t index) &#123; &#125;); 05 队列组（同栅栏函数） //创建队列组 dispatch_group_t group = dispatch_group_create(); //队列组中的任务执行完毕之后，执行该函数 dispatch_group_notify(dispatch_group_t group,dispatch_queue_t queue,dispatch_block_t block); 06进入群组和离开群组 dispatch_group_enter(group);//执行该函数后，后面异步执行的block会被gruop监听 dispatch_group_leave(group);//异步block中，所有的任务都执行完毕，最后离开群组 //注意：dispatch_group_enter|dispatch_group_leave必须成对使用 5.容易混淆的术语有四个术语容易混淆：同步、异步、并发、串行 同步和异步主要影响：能不能开启新的线程 同步：只是在当前线程中执行任务，不具备开启新线程的能力 异步：可以在新的线程中执行任务，具备开启新线程的能力 并发和串行主要影响：任务的执行方式 并发：允许多个任务并发（同时）执行 串行：一个任务执行完毕后，在执行下一个任务","tags":[{"name":"iOS学习","slug":"iOS学习","permalink":"http://binngirl.com/tags/iOS学习/"}]},{"title":"Modal","date":"2016-06-06T14:06:29.000Z","path":"2016/06/06/Modal/","text":"","tags":[{"name":"iOS学习","slug":"iOS学习","permalink":"http://binngirl.com/tags/iOS学习/"}]},{"title":"FMDB","date":"2016-06-02T14:04:52.000Z","path":"2016/06/02/FMDB/","text":"","tags":[{"name":"iOS学习","slug":"iOS学习","permalink":"http://binngirl.com/tags/iOS学习/"}]},{"title":"加密概述(网络资料整理)","date":"2016-05-13T14:04:17.000Z","path":"2016/05/13/加密概述/","text":"一.MD5加密MD5主要特点是不可逆，相同数据的MD5值肯定一样，不同数据的MD5值不一样（也不是绝对的，但基本是不能一样的）。 MD5算法还具有以下性质： 1. **压缩性**：任意长度的数据，算出的MD5值长度都是固定的。 2. **容易计算**：从原数据计算出MD5值很容易。 3. **抗修改性**：对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。 4. **弱抗碰撞**：已知原数据和其MD5值，想找到一个具有相同MD5值的数据（即伪造数据）是非常困难的。 5. **强抗碰撞**：想找到两个不同的数据，使它们具有相同的MD5值，是非常困难的。 MD5虽然说是不可逆的 但是由于有网站cmd5.com专门用来查询MD5码,所以有的简单的MD5码是可以在这里搜到源码的。 为了让MD5码更加安全,涌现了很多其他方法 如加盐。盐要足够长足够乱，得到的MD5码就很难查到。 终端代码：$ echo -n abc|openssl md5 给字符串abc加密。 二.base64加密在MIME格式的电子邮件中，base64可以用来将binary的字节序列数据编码成ASCII字符序列构成的文本。使用时，在传输编码方式中指定base64。使用的字符包括大小写字母各26个，加上10个数字，和加号“+”，斜杠“/”，一共64个字符，等号“=”用来作为后缀用途。 完整的base64定义可见RFC 1421和RFC 2045。编码后的数据比原始数据略长，为原来的4/3。 原理图如下 终端指令：先cd 找到当前目录加密：$ base64 abc.png -o abc.txt 解密： $ base64 abc.txt -o 123.png -D 三.对称加密算法优点：算法公开、计算量小、加密速度快、加密效率高、可逆； 缺点：双方使用相同钥匙，安全性得不到保证； 现状：对称加密的速度比公钥加密快很多，在很多场合都需要对称加密， 相较于DES和3DES算法而言，AES算法有着更高的速度和资源使用效率，安全级别也较之更高了，被称为下一代加密标准 nECB ：电子代码本，就是说每个块都是独立加密的 nCBC ：密码块链，使用一个密钥和一个初始化向量 (IV)对数据执行加密转换 ECB和CBC区别：CBC更加复杂更加安全，里面加入了8位的向量（8个0的话结果等于ECB）。在明文里面改一个字母，ECB密文对应的那一行会改变，CBC密文从那一行往后都会改变。 ECB终端命令： $ openssl enc -des-ecb -K 616263 -nosalt -in msg1.txt -out msg1.bin CBC终端命令： $ openssl enc -des-cbc -K 616263 -iv 0000000000000000 -nosalt -in msg1.txt -out msg2.bin 四.RSA加密RSA非对称加密算法 非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey） 公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。 特点： 非对称密码体制的特点：算法强度复杂、安全性依赖于算法与密钥但是由于其算法复杂，而使得加密解密速度没有对称加密解密的速度快 对称密码体制中只有一种密钥，并且是非公开的，如果要解密就得让对方知道密钥。所以保证其安全性就是保证密钥的安全，而非对称密钥体制有两种密钥，其中一个是公开的，这样就可以不需要像对称密码那样传输对方的密钥了 基本加密原理： (1)找出两个“很大”的质数：P &amp; Q (2)N = P * Q (3)M = (P – 1) * (Q – 1) (4)找出整数E，E与M互质，即除了1之外，没有其他公约数 (5)找出整数D，使得ED除以M余1，即 (E D) % M = 1 经过上述准备工作之后，可以得到： E是公钥，负责加密 D是私钥，负责解密 N负责公钥和私钥之间的联系 加密算法，假定对X进行加密 (X ^ E) % N = Y n根据费尔马小定义，根据以下公式可以完成解密操作 (Y ^ D) % N = X 但是RSA加密算法效率较差，对大型数据加密时间很长，一般用于小数据。 常用场景： 分部要给总部发一段报文，先对报文整个进行MD5得到一个报文摘要，再对这个报文摘要用公钥加密。然后把报文和这个RSA密文一起发过去。 总部接收到报文之后要先确定报文是否在中途被人篡改，就先把这个密文用私钥解密得到报文摘要，再和整个报文MD5一下得到的报文摘要进行对比 如果一样就是没被改过。","tags":[{"name":"iOS学习","slug":"iOS学习","permalink":"http://binngirl.com/tags/iOS学习/"}]},{"title":"关于MD5","date":"2016-04-10T14:03:53.000Z","path":"2016/04/10/关于MD5/","text":"什么是MD5? MD5全称是Message Digest Algorithm 5，译为“消息摘要算法第5版” 效果：对输入信息生成唯一的128位散列值（32个字符） MD5的特点： 输入两个不同的明文不会得到相同的输出值 根据输出值，不能得到原始的明文，即其过程不可逆 MD5改进： 加盐（Salt）：在明文的固定位置插入随机串，然后再进行MD5。 先加密，后乱序：先对明文进行MD5，然后对加密得到的MD5串的字符进行乱序。 栗子： 导入NSString+hash.h封装好的加密分类算法下面是封装好的demo： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#import &quot;ViewController.h&quot;#import &quot;NSString+Hash.h&quot;@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; [self MD5]; [self MD5Salt:@&quot;san&quot;]; [self doubleMD5]; [self MD5Reorder];&#125;//MD5加密-(void)MD5&#123; NSString *pwd = @&quot;123456&quot;; NSString *pwdMD5 = [pwd md5String]; NSLog(@&quot;%@&quot;,pwdMD5);&#125;/** * 撒盐 加密 MD5($pass.$salt) */-(void)MD5Salt:(NSString *)salt&#123; NSString *pwd = @&quot;123456&quot;; pwd =[pwd stringByAppendingString:salt]; 撒盐：随机地往明文中插入任意字符串 NSString *pwdMD5 = [pwd md5String]; NSLog(@&quot;%@&quot;,pwdMD5);&#125;/** * MD5(MD5($pass)) */- (void)doubleMD5&#123; NSString *pwd = @&quot;123456&quot;; NSString *pwdMD5MD5 = [[pwd md5String]md5String]; NSLog(@&quot;%@&quot;,pwdMD5MD5);&#125;/** * 先加密，后乱序 */- (void)MD5Reorder&#123; NSString *pwd = @&quot;123456&quot;; NSString *pwdMD5 = [pwd md5String]; NSLog(@&quot;oldpwdMD5=%@&quot;,pwdMD5); NSString *prefix = [pwdMD5 substringFromIndex:3]; 从下标为3的开始截取（包含3） NSString *subfix = [pwdMD5 substringToIndex:3]; 截取0到3的字符串（不包含3） pwdMD5 = [prefix stringByAppendingString:subfix]; NSLog(@&quot;newpwdMD5=%@&quot;,pwdMD5);&#125;@end","tags":[{"name":"iOS学习","slug":"iOS学习","permalink":"http://binngirl.com/tags/iOS学习/"}]},{"title":"KVC/KVO","date":"2016-01-20T14:19:20.000Z","path":"2016/01/20/KVC-KVO/","text":"","tags":[{"name":"iOS学习","slug":"iOS学习","permalink":"http://binngirl.com/tags/iOS学习/"}]}]