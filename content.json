[{"title":"初识热更新","date":"2017-02-21T07:17:02.000Z","path":"2017/02/21/初识热更新/","text":"每次提交版本都得等待一周到两周的审核时间，我是受不了这种速度了，于是决定研究有没有其他的方法跳过提交版本这个步骤，同样能够修复bug呢，于是找到了JSPatch，也许也有很多人觉得这是个很高大上的技术，其实不然，我们只需要在项目里引入极小的引擎文件，就可以使用 JavaScript 调用任何 Objective-C 的原生接口，替换任意 Objective-C 原生方法。当然呢，目前主要用于下发 JS 脚本替换原生 Objective-C 代码，实时修复线上 bug。 首先说一下JSPatch实现的内部原理：JsPatch能做到通过JS调用和改写OC方法最根本的原因是 Objective-C 是动态语言，OC上所有方法的调用、类的生成都通过 Objective-C Runtime 在运行时进行，我们可以通过类名和方法名反射得到相应的类和方法，也可以替换某个类的方法为新的实现，还可以新注册一个类，为类添加方法。所以 JSPatch 的原理就是：JS传递字符串给OC，OC通过 Runtime 接口调用和替换OC方法。这个很容易理解，JS的作用只是一个信使的作用，具体实现还是得靠我们OC,所以说OC还是世界上最美的语言，哈哈。 同时在这里介绍一个比较好的网站 点这里.这是一个OC转JS的一个工具网站。 下面演示一下具体实现的步骤 123456789101112131415161718192021222324252627282930313233343536- (void)viewDidLoad&#123; UITableView* tv = [[UITableView alloc]initWithFrame:self.view.bounds style:UITableViewStylePlain]; self.mqTableView = tv; self.mqTableView.delegate = self; self.mqTableView.dataSource = self; [self.view addSubview:self.mqTableView];&#125;#pragma mark -- UITableViewDataSource- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section&#123; return 3;&#125;- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; static NSString* i= @&quot;cell&quot;; UITableViewCell* cell = [tableView dequeueReusableCellWithIdentifier:i]; if (cell == nil ) &#123; cell =[[UITableViewCell alloc]initWithStyle:UITableViewCellStyleDefault reuseIdentifier:i]; &#125; cell.textLabel.text = @&quot;meiqing&quot;; cell.backgroundColor = [UIColor whiteColor]; return cell;&#125;- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath&#123; self.dataSource = @[@&quot;1&quot;,@&quot;2&quot;]; 肯定会超出数组范围导致 crash NSString *content = self.dataSource[indexPath.row];&#125; 显示的结果是这样的上面的图片是没有修改时候的显示，当我点击第三行一定会闪退，怎么修复呢？这个时候就不用发版本了，服务器可以给我们传送一个js文件，文件里的内容是这样的：同时，我们在APPDelegate里调用这个JS就可以了，如下：再次运行就不会出现闪退了。","tags":[{"name":"iOS学习","slug":"iOS学习","permalink":"http://binngirl.com/tags/iOS学习/"}]},{"title":"对人工智能的一点看法","date":"2017-02-06T12:06:51.000Z","path":"2017/02/06/对人工智能的一点看法/","text":"下午茶时间在公司附近超市闲逛，发现这家超市多了几台自助收银机，顾客买了商品后，用机器自助扫描，自助付款，全程没有收银员参与，这让我想起一年前去中国银行办卡，第一次用到的自助办卡机，有了这个机器，顾客不用和柜员直接面对面了，但仍需要柜员，只不过柜员在机器的那头远程为顾客办理业务，这样的办公模式大大提高了银行的服务效率！也许再过一段时间，银行将不需要柜员，纯机器就可以办理业务，这也意味着必将有一批银行柜员和超市收银员失业或转岗…… 进入16年，人工智能越来越多的进入到普通人的生活中，从智能家居到可穿戴设备再到自动驾驶，从AlphaGo战胜李世石开始，各大科技巨头就纷纷开始布局人工智能，富士康已经用大量机器人代替了数万名流水线工人……不少行业大佬预计2017年将是人工智能飞速发展的一年，作为一名移动端开发程序员，面对人工智能，我是有些恐慌的，既然司机和律师这样专业性较强的职业都会被人工智能取代，那么部分程序员也必将被人工智能取代，随着小程序和混合开发的出现，彻底的原生app越来越少，也许很快人工智能就能自己开发app了，初级程序员会像部分收银员和银行柜员一样，要么失业要么转岗，但是话说回来，作为一名程序员，如果没有基本的独立思考能力和自学能力，不管在何时都很难赶上科技发展的浪潮，最终被拍死在沙滩上…… 最近网上不少大咖推荐《未来简史》这本书，据说是本非常开脑洞的书，为了对未来有更好的准备，或许该买来看看！未来已经到来，人工智能只是导火索，只有活在未来的人很难被淘汰，所以要努力成为一个活在未来的人！","tags":[{"name":"随笔","slug":"随笔","permalink":"http://binngirl.com/tags/随笔/"}]},{"title":"git使用简单总结","date":"2017-01-16T15:07:02.000Z","path":"2017/01/16/git使用简单总结/","text":"几个概念： 工作区：仓库文件夹里除.git目录以外的内容 版本库：.git目录，用于存储记录版本信息 暂缓区（stage） 分支（master）：git自动创建的第一个分支 HEAD指针：用于指向当前分支 注：显示隐藏文件命令： defaults write com.apple.finder AppleShowAllFiles -bool true(false) 一、个人演练（命令行演练） 进入到工作目录中，初始化一个代码仓库：git init 给该git仓库配置一个用户名和邮箱：git config user.name “gengbinghan”git config user.email “9777@qq.com” 初始化代码：touch main.m -&gt; git status -&gt; Untracked files:（红色文件）：新添加或者新修改的文件在工作区中，没有被添加到暂缓区中git add main.m -&gt; git status -&gt; Changes to be committed:（绿色文件） :将工作区的代码已经添加到暂缓区，可以提交到代码仓库中了 查看文件的状态：git status Untracked files:(红色文件)：新添加或者新修改的文件在工作区中，没有被添加到暂缓区中 Changes to be committed:（绿色文件） :将工作区的代码已经添加到暂缓区，可以提交到代码仓库中了 git commit -m “xxxx”（提交代码）[master (root-commit) 949712f] 初始化项目1 file changed, 0 insertions(+), 0 deletions(-)create mode 100644 main.m 修改文件：open main.m git add .将工作区所有的文件添加到暂缓区里面 给git命令其别名:git config alias.要起的别名 “要给谁其别名”例: git config alias.ci “commit -m” 查看历史版本git loggit 版本号：61d5d0c23e7e1b772c32829ed2feb130728fae66 git版本号是由sha1加密算法生成的一个40位的哈希值git reflog 版本回退git reset –hard HEAD：回退当前版本（当前版本未提交）git reset –hard 版本号 –global的作用（配置全局的用户名和密码，其他地方可以不配置） git config –global user.name “gengbinghan” git config –glabal user.email “9777@qq.com” 二、团队开发（共享版本库）文件夹/U盘/Github/oschina 创建一个代码共享库（让一个文件夹成为共享库）git init – bare 经理将我们的共享代码仓库中的内容clone下来git clone 地址 项目经理初始化项目 忽略文件：在我们的.git 同级目录下创建一个.gitignore文件，在该文件中指定需要忽略的文件 github上搜索：.gitignore -&gt; 打开ObjectiveC -&gt; 复制文件内容到新建的.ignore文件中(https://github.com/github/gitignore/blob/master/Objective-C.gitignore) git add . -&gt; git commit –m “注释”，将.gitignore添加到本地仓库管理中 OSChina和Github的使用","tags":[{"name":"iOS学习","slug":"iOS学习","permalink":"http://binngirl.com/tags/iOS学习/"}]},{"title":"运动给我势能","date":"2017-01-11T14:49:11.000Z","path":"2017/01/11/运动给我势能/","text":"坚持慢跑和健身有一段时间了，16年中旬开始用keep健身，中间跳了几周insanity（太伤膝盖，已放弃），年底开始用咕咚跑步，下面两张图是目前为止我的运动数据： 在日常生活中也不难发现，长期运动的人精神面貌会比不爱运动的人更好，有一种健康的，朝气蓬勃气质（看下宁泽涛、孙杨就知道），虽然持续运动的时间不算长，但我已切身感受到运动给我的生活带来了改变：敲代码更加专注了，工作效率更高了，负面情绪变少了，气色变好了……于是，对大部分人来说痛苦的运动逐渐变成了我的每日刚需……当然，运动带给我更多的是一种势能，不管是慢跑还是有氧健身，每次运动结束，都会觉得浑身充满力量，生活变得更有动力，态度也更加积极，以至于每次跑步都停不下来，甚至到了不运动不舒服地步……我会持续运动下去，没有终点！","tags":[{"name":"随笔","slug":"随笔","permalink":"http://binngirl.com/tags/随笔/"}]},{"title":"关于GCD","date":"2017-01-10T14:44:54.000Z","path":"2017/01/10/关于GCD/","text":"1.GCD基本知识01.两个核心概念——队列和任务 任务：执行什么操作队列：用来存放任务 02.同步函数和异步函数 2.GCD基本使用GCD的使用就两个步骤：定制任务确定想做的事、将任务添加到队列中： 1.GCD会自动将队列中的任务取出，放到对应的线程中执行2.任务的取出遵循队列的FIFO原则：先进先出，后进后出 01.异步函数+并发队列：开启多条线程，并发执行任务 02.异步函数+串行对列：开启一条线程，串行执行任务 03.同步函数+并发队列：不开线程，并发执行任务 04.同步函数+串行对列：不开线程，串行执行任务 05.异步函数+主队列：不开线程，在主队列中串行执行任务 06.同步函数+主队列：不开线程，串行执行任务（注意死锁发生） 07.注意同步函数和异步函数在执行顺序上的差异 3.GCD线程间通信123456789101112131415161718192021//0.获取一个全局的队列 dispatch_queue_t queue = dispatch_get_global_queue(0, 0); //1.先开启一个线程，把下载图片的操作放在子线程中处理 dispatch_async(queue, ^&#123; //2.下载图片 NSURL *url = [NSURL URLWithString:@&quot;http://h.hiphotos.baidu.com/zhidao/pic/item/6a63f6246b600c3320b14bb3184c510fd8f9a185.jpg&quot;]; NSData *data = [NSData dataWithContentsOfURL:url]; UIImage *image = [UIImage imageWithData:data]; NSLog(@&quot;下载操作所在的线程--%@&quot;,[NSThread currentThread]); //3.回到主线程刷新UI dispatch_async(dispatch_get_main_queue(), ^&#123; self.imageView.image = image; //打印查看当前线程 NSLog(@&quot;刷新UI---%@&quot;,[NSThread currentThread]); &#125;); &#125;); 4.GCD其他常用函数12345678910111213141516171819202122232425262728293031323334353601 栅栏函数（控制任务的执行顺序） dispatch_barrier_async(queue, ^&#123; NSLog(@&quot;--dispatch_barrier_async-&quot;); &#125;); 02 延迟执行（延迟·控制在哪个线程执行） dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; NSLog(@&quot;---%@&quot;,[NSThread currentThread]); &#125;); 03 一次性代码（注意不能放到懒加载） -(void)once &#123; //整个程序运行过程中只会执行一次 //onceToken用来记录该部分的代码是否被执行过 static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; NSLog(@&quot;-----&quot;); &#125;); &#125; 04 快速迭代（开多个线程并发完成迭代操作） dispatch_apply(subpaths.count, queue, ^(size_t index) &#123; &#125;); 05 队列组（同栅栏函数） //创建队列组 dispatch_group_t group = dispatch_group_create(); //队列组中的任务执行完毕之后，执行该函数 dispatch_group_notify(dispatch_group_t group,dispatch_queue_t queue,dispatch_block_t block); 06进入群组和离开群组 dispatch_group_enter(group);//执行该函数后，后面异步执行的block会被gruop监听 dispatch_group_leave(group);//异步block中，所有的任务都执行完毕，最后离开群组 //注意：dispatch_group_enter|dispatch_group_leave必须成对使用 5.容易混淆的术语有四个术语容易混淆：同步、异步、并发、串行 同步和异步主要影响：能不能开启新的线程 同步：只是在当前线程中执行任务，不具备开启新线程的能力 异步：可以在新的线程中执行任务，具备开启新线程的能力 并发和串行主要影响：任务的执行方式 并发：允许多个任务并发（同时）执行 串行：一个任务执行完毕后，在执行下一个任务","tags":[{"name":"iOS学习","slug":"iOS学习","permalink":"http://binngirl.com/tags/iOS学习/"}]},{"title":"Modal","date":"2016-06-06T14:06:29.000Z","path":"2016/06/06/Modal/","text":"简介 在iPhone开发中 Modal是一种常见的切换控制器的方式 默认是从屏幕底部往上弹出，直到完全盖住后面的内容为止 在iPad开发中 Modal的使用频率也是非常高的 对比iPhone开发，Modal在iPad开发中多了一些用法 呈现样式 什么叫呈现样式 Modal出来的控制器，最终显示出来的样子 Modal常见有4种呈现样式 UIModalPresentationFullScreen ：全屏显示（默认） UIModalPresentationPageSheet 宽度：竖屏时的宽度（768） 高度：当前屏幕的高度（填充整个高度） UIModalPresentationFormSheet ：占据屏幕中间的一小块 UIModalPresentationCurrentContext ：跟随父控制器的呈现样式 过渡样式 什么叫过渡样式 Modal出来的控制器，是以怎样的动画呈现出来 Modal一共4种过渡样式 UIModalTransitionStyleCoverVertical ：从底部往上钻（默认） UIModalTransitionStyleFlipHorizontal ：三维翻转 UIModalTransitionStyleCrossDissolve ：淡入淡出 UIModalTransitionStylePartialCurl ：翻页（只显示部分，使用前提：呈现样式必须是UIModalPresentationFullScreen）","tags":[{"name":"iOS学习","slug":"iOS学习","permalink":"http://binngirl.com/tags/iOS学习/"}]},{"title":"FMDB","date":"2016-06-02T14:04:52.000Z","path":"2016/06/02/FMDB/","text":"什么是FMDB FMDB是iOS平台的SQLite数据库框架 FMDB以OC的方式封装了SQLite的C语言API FMDB的优点 使用起来更加面向对象，省去了很多麻烦、冗余的C语言代码 提供了多线程安全的数据库操作方法，有效地防止数据混乱 FMDB的github地址 https://github.com/ccgus/fmdb 核心类 FMDB有三个主要的类 FMDatabase：一个FMDatabase对象就代表一个单独的SQLite数据库用来执行SQL语句。 FMResultSet：使用FMDatabase执行查询后的结果集。 FMDatabaseQueue：用于在多线程中执行多个查询或更新，它是线程安全的。 打开数据库 通过指定SQLite数据库文件路径来创建FMDatabase对象 123456FMDatabase *db = [FMDatabase databaseWithPath:path];if (![db open]) &#123; NSLog(@&quot;数据库打开失败！&quot;);&#125; 文件路径有三种情况 具体文件路径 如果不存在会自动创建 空字符串@”” 会在临时目录创建一个空的数据库 当FMDatabase连接关闭时，数据库文件也被删除 nil 会创建一个内存中临时数据库，当FMDatabase连接关闭时，数据库会被销毁 执行更新 在FMDB中，除查询以外的所有操作，都称为“更新” create、drop、insert、update、delete等 使用executeUpdate:方法执行更新 1- (BOOL)executeUpdate:(NSString*)sql, ... 1- (BOOL)executeUpdateWithFormat:(NSString*)format, ... 1- (BOOL)executeUpdate:(NSString*)sql withArgumentsInArray:(NSArray *)arguments 示例 1[db executeUpdate:@&quot;UPDATE t_student SET age = ? WHERE name = ?;&quot;, @20, @&quot;Jack&quot;] 执行查询 查询方法 (FMResultSet )executeQuery:(NSString)sql, … (FMResultSet )executeQueryWithFormat:(NSString)format, … (FMResultSet )executeQuery:(NSString )sql withArgumentsInArray:(NSArray *)arguments 示例 12查询数据FMResultSet *rs = [db executeQuery:@&quot;SELECT * FROM t_student&quot;]; 遍历结果集 12345678while ([rs next]) &#123; NSString *name = [rs stringForColumn:@&quot;name&quot;]; int age = [rs intForColumn:@&quot;age&quot;]; double score = [rs doubleForColumn:@&quot;score&quot;];&#125; FMDatabaseQueue FMDatabase这个类是线程不安全的，如果在多个线程中同时使用一个FMDatabase实例，会造成数据混乱等问题 为了保证线程安全，FMDB提供方便快捷的FMDatabaseQueue类 FMDatabaseQueue的创建 1FMDatabaseQueue *queue = [FMDatabaseQueue databaseQueueWithPath:path]; FMDatabaseQueue 简单使用 1234567891011121314151617[queue inDatabase:^(FMDatabase *db) &#123; [db executeUpdate:@&quot;INSERT INTO t_student(name) VALUES (?)&quot;, @&quot;Jack&quot;]; [db executeUpdate:@&quot;INSERT INTO t_student(name) VALUES (?)&quot;, @&quot;Rose&quot;]; [db executeUpdate:@&quot;INSERT INTO t_student(name) VALUES (?)&quot;, @&quot;Jim&quot;]; FMResultSet *rs = [db executeQuery:@&quot;select * from t_student&quot;]; while ([rs next]) &#123; &#125;&#125;]; FMDatabaseQueue 使用事务 123456789101112131415[queue inTransaction:^(FMDatabase *db, BOOL *rollback) &#123; [db executeUpdate:@&quot;INSERT INTO t_student(name) VALUES (?)&quot;, @&quot;Jack&quot;]; [db executeUpdate:@&quot;INSERT INTO t_student(name) VALUES (?)&quot;, @&quot;Rose&quot;]; [db executeUpdate:@&quot;INSERT INTO t_student(name) VALUES (?)&quot;, @&quot;Jim&quot;]; FMResultSet *rs = [db executeQuery:@&quot;select * from t_student&quot;]; while ([rs next]) &#123; // … &#125;&#125;]; 事务回滚 1rollback = YES;","tags":[{"name":"iOS学习","slug":"iOS学习","permalink":"http://binngirl.com/tags/iOS学习/"}]},{"title":"加密概述(网络资料整理)","date":"2016-05-13T14:04:17.000Z","path":"2016/05/13/加密概述/","text":"一.MD5加密MD5主要特点是不可逆，相同数据的MD5值肯定一样，不同数据的MD5值不一样（也不是绝对的，但基本是不能一样的）。 MD5算法还具有以下性质： 1. **压缩性**：任意长度的数据，算出的MD5值长度都是固定的。 2. **容易计算**：从原数据计算出MD5值很容易。 3. **抗修改性**：对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。 4. **弱抗碰撞**：已知原数据和其MD5值，想找到一个具有相同MD5值的数据（即伪造数据）是非常困难的。 5. **强抗碰撞**：想找到两个不同的数据，使它们具有相同的MD5值，是非常困难的。 MD5虽然说是不可逆的 但是由于有网站cmd5.com专门用来查询MD5码,所以有的简单的MD5码是可以在这里搜到源码的。 为了让MD5码更加安全,涌现了很多其他方法 如加盐。盐要足够长足够乱，得到的MD5码就很难查到。 终端代码：$ echo -n abc|openssl md5 给字符串abc加密。 二.base64加密在MIME格式的电子邮件中，base64可以用来将binary的字节序列数据编码成ASCII字符序列构成的文本。使用时，在传输编码方式中指定base64。使用的字符包括大小写字母各26个，加上10个数字，和加号“+”，斜杠“/”，一共64个字符，等号“=”用来作为后缀用途。 完整的base64定义可见RFC 1421和RFC 2045。编码后的数据比原始数据略长，为原来的4/3。 原理图如下 终端指令：先cd 找到当前目录加密：$ base64 abc.png -o abc.txt 解密： $ base64 abc.txt -o 123.png -D 三.对称加密算法优点：算法公开、计算量小、加密速度快、加密效率高、可逆； 缺点：双方使用相同钥匙，安全性得不到保证； 现状：对称加密的速度比公钥加密快很多，在很多场合都需要对称加密， 相较于DES和3DES算法而言，AES算法有着更高的速度和资源使用效率，安全级别也较之更高了，被称为下一代加密标准 nECB ：电子代码本，就是说每个块都是独立加密的 nCBC ：密码块链，使用一个密钥和一个初始化向量 (IV)对数据执行加密转换 ECB和CBC区别：CBC更加复杂更加安全，里面加入了8位的向量（8个0的话结果等于ECB）。在明文里面改一个字母，ECB密文对应的那一行会改变，CBC密文从那一行往后都会改变。 ECB终端命令： $ openssl enc -des-ecb -K 616263 -nosalt -in msg1.txt -out msg1.bin CBC终端命令： $ openssl enc -des-cbc -K 616263 -iv 0000000000000000 -nosalt -in msg1.txt -out msg2.bin 四.RSA加密RSA非对称加密算法 非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey） 公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。 特点： 非对称密码体制的特点：算法强度复杂、安全性依赖于算法与密钥但是由于其算法复杂，而使得加密解密速度没有对称加密解密的速度快 对称密码体制中只有一种密钥，并且是非公开的，如果要解密就得让对方知道密钥。所以保证其安全性就是保证密钥的安全，而非对称密钥体制有两种密钥，其中一个是公开的，这样就可以不需要像对称密码那样传输对方的密钥了 基本加密原理： (1)找出两个“很大”的质数：P &amp; Q (2)N = P * Q (3)M = (P – 1) * (Q – 1) (4)找出整数E，E与M互质，即除了1之外，没有其他公约数 (5)找出整数D，使得ED除以M余1，即 (E D) % M = 1 经过上述准备工作之后，可以得到： E是公钥，负责加密 D是私钥，负责解密 N负责公钥和私钥之间的联系 加密算法，假定对X进行加密 (X ^ E) % N = Y n根据费尔马小定义，根据以下公式可以完成解密操作 (Y ^ D) % N = X 但是RSA加密算法效率较差，对大型数据加密时间很长，一般用于小数据。 常用场景： 分部要给总部发一段报文，先对报文整个进行MD5得到一个报文摘要，再对这个报文摘要用公钥加密。然后把报文和这个RSA密文一起发过去。 总部接收到报文之后要先确定报文是否在中途被人篡改，就先把这个密文用私钥解密得到报文摘要，再和整个报文MD5一下得到的报文摘要进行对比 如果一样就是没被改过。","tags":[{"name":"iOS学习","slug":"iOS学习","permalink":"http://binngirl.com/tags/iOS学习/"}]},{"title":"关于MD5","date":"2016-04-10T14:03:53.000Z","path":"2016/04/10/关于MD5/","text":"什么是MD5? MD5全称是Message Digest Algorithm 5，译为“消息摘要算法第5版” 效果：对输入信息生成唯一的128位散列值（32个字符） MD5的特点： 输入两个不同的明文不会得到相同的输出值 根据输出值，不能得到原始的明文，即其过程不可逆 MD5改进： 加盐（Salt）：在明文的固定位置插入随机串，然后再进行MD5。 先加密，后乱序：先对明文进行MD5，然后对加密得到的MD5串的字符进行乱序。 栗子： 导入NSString+hash.h封装好的加密分类算法下面是封装好的demo： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#import &quot;ViewController.h&quot;#import &quot;NSString+Hash.h&quot;@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; [self MD5]; [self MD5Salt:@&quot;san&quot;]; [self doubleMD5]; [self MD5Reorder];&#125;//MD5加密-(void)MD5&#123; NSString *pwd = @&quot;123456&quot;; NSString *pwdMD5 = [pwd md5String]; NSLog(@&quot;%@&quot;,pwdMD5);&#125;/** * 撒盐 加密 MD5($pass.$salt) */-(void)MD5Salt:(NSString *)salt&#123; NSString *pwd = @&quot;123456&quot;; pwd =[pwd stringByAppendingString:salt]; 撒盐：随机地往明文中插入任意字符串 NSString *pwdMD5 = [pwd md5String]; NSLog(@&quot;%@&quot;,pwdMD5);&#125;/** * MD5(MD5($pass)) */- (void)doubleMD5&#123; NSString *pwd = @&quot;123456&quot;; NSString *pwdMD5MD5 = [[pwd md5String]md5String]; NSLog(@&quot;%@&quot;,pwdMD5MD5);&#125;/** * 先加密，后乱序 */- (void)MD5Reorder&#123; NSString *pwd = @&quot;123456&quot;; NSString *pwdMD5 = [pwd md5String]; NSLog(@&quot;oldpwdMD5=%@&quot;,pwdMD5); NSString *prefix = [pwdMD5 substringFromIndex:3]; 从下标为3的开始截取（包含3） NSString *subfix = [pwdMD5 substringToIndex:3]; 截取0到3的字符串（不包含3） pwdMD5 = [prefix stringByAppendingString:subfix]; NSLog(@&quot;newpwdMD5=%@&quot;,pwdMD5);&#125;@end","tags":[{"name":"iOS学习","slug":"iOS学习","permalink":"http://binngirl.com/tags/iOS学习/"}]},{"title":"KVC/KVO","date":"2016-01-20T14:19:20.000Z","path":"2016/01/20/KVC-KVO/","text":"键值编码KVC我们知道在C#中可以通过反射读写一个对象的属性，有时候这种方式特别方便，因为你可以利用字符串的方式去动态控制一个对象。其实由于ObjC的语言特性，你根本不必进行任何操作就可以进行属性的动态读写，这种方式就是Key Value Coding（简称KVC）。 KVC的操作方法由NSKeyValueCoding协议提供，而NSObject就实现了这个协议，也就是说ObjC中几乎所有的对象都支持KVC操作，常用的KVC操作方法如下： 动态设置： setValue:属性值 forKey:属性名（用于简单路径）、setValue:属性值 forKeyPath:属性路径（用于复合路径，例如Person有一个Account类型的属性，那么person.account就是一个复合属性） 动态读取：valueForKey:属性名 、valueForKeyPath:属性名（用于复合路径）下面通过一个例子来理解KVC 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#import &lt;Foundation/Foundation.h&gt;@interface Account : NSObject#pragma mark - 属性#pragma mark 余额@property (nonatomic,assign) float balance;@end #import &quot;Account.h&quot; @implementation Account@endPerson.h#import &lt;Foundation/Foundation.h&gt;@class Account;@interface Person : NSObject&#123;@private int _age;&#125;#pragma mark - 属性#pragma mark 姓名@property (nonatomic,copy) NSString *name;#pragma mark 账户@property (nonatomic,retain) Account *account;#pragma mark - 公共方法#pragma mark 显示人员信息-(void)showMessage;@endPerson.m#import &quot;Person.h&quot;@implementation Person#pragma mark - 公共方法#pragma mark 显示人员信息-(void)showMessage&#123; NSLog(@&quot;name=%@,age=%d&quot;,_name,_age);&#125;@endmain.m#import &lt;Foundation/Foundation.h&gt;#import &quot;Person.h&quot;#import &quot;Account.h&quot;int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; Person *person1=[[Person alloc]init]; [person1 setValue:@&quot;Kenshin&quot; forKey:@&quot;name&quot;]; [person1 setValue:@28 forKey:@&quot;age&quot;]; 注意即使一个私有变量仍然可以访问 [person1 showMessage]; 结果：name=Kenshin,age=28 NSLog(@&quot;person1&apos;s name is :%@,age is :%@&quot;,person1.name,[person1 valueForKey:@&quot;age&quot;]); 结果：person1&apos;s name is :Kenshin,age is :28 Account *account1=[[Account alloc]init]; person1.account=account1;注意这一步一定要先给account属性赋值，否则下面按路径赋值无法成功，因为account为nil，当然这一步骤也可以写成:[person1 setValue:account1 forKeyPath:@&quot;account&quot;]; [person1 setValue:@100000000.0 forKeyPath:@&quot;account.balance&quot;]; NSLog(@&quot;person1&apos;s balance is :%.2f&quot;,[[person1 valueForKeyPath:@&quot;account.balance&quot;] floatValue]);、 结果：person1&apos;s balance is :100000000.00 &#125; return 0;&#125; KVC使用起来比较简单，但是它如何查找一个属性进行读取呢？具体查找规则（假设现在要利用KVC对a进行读取）： 如果是动态设置属性，则优先考虑调用setA方法，如果没有该方法则优先考虑搜索成员变量_a,如果仍然不存在则搜索成员变量a，如果最后仍然没搜索到则会调用这个类的setValue:forUndefinedKey：方法(注意搜索过程中不管这些方法、成员变量是私有的还是公共的都能正确设置)； 如果是动态读取属性，则优先考虑调用a方法（属性a的getter方法），如果没有搜索到则会优先搜索成员变量_a，如果仍然不存在则搜索成员变量a，如果最后仍然没搜索到则会调用这个类的valueforUndefinedKey:方法(注意搜索过程中不管这些方法、成员变量是私有的还是公共的都能正确读取)； 键值监听KVOKVO其实是一种观察者模式，利用它可以很容易实现视图组件和数据模型的分离，当数据模型的属性值改变之后作为监听器 的视图组件就会被激发，激发时就会回调监听器自身。在ObjC中要实现KVO则必须实现NSKeyValueObServing协议，不过幸运的是 NSObject已经实现了该协议，因此几乎所有的ObjC对象都可以使用KVO。 在ObjC中使用KVO操作常用的方法如下： 注册指定Key路径的监听器： addObserver: forKeyPath: options: context: 删除指定Key路径的监听器： removeObserver: forKeyPath、removeObserver: forKeyPath: context: 回调监听： observeValueForKeyPath: ofObject: change: context: KVO的使用步骤也比较简单： 通过addObserver: forKeyPath: options: context:为被监听对象（它通常是数据模型）注册监听器 重写监听器的observeValueForKeyPath: ofObject: change: context:方法 由于我们还没有介绍过IOS的界面编程，这里我们还是在上面的例子基础上继续扩展，假设当我们的账户余额balance变动之后我们希望用户可以及 时获得通知。那么此时Account就作为我们的被监听对象，需要Person为它注册监听（使用addObserver: forKeyPath: options: context:）;而人员Person作为监听器需要重写它的observeValueForKeyPath: ofObject: change: context:方法，当监听的余额发生改变后会回调监听器Person监听方法（observeValueForKeyPath: ofObject: change: context:）。下面通过代码模拟上面的过程： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#import &lt;Foundation/Foundation.h&gt; @interface Account : NSObject#pragma mark - 属性#pragma mark 余额@property (nonatomic,assign) float balance;@endAccount.m#import &quot;Account.h&quot;@implementation Account@endPerson.h#import &lt;Foundation/Foundation.h&gt;@class Account;@interface Person : NSObject&#123;@private int _age;&#125;#pragma mark - 属性#pragma mark 姓名@property (nonatomic,copy) NSString *name;#pragma mark 账户@property (nonatomic,retain) Account *account;#pragma mark - 公共方法#pragma mark 显示人员信息-(void)showMessage;@end#import &quot;Person.h&quot;#import &quot;Account.h&quot;@implementation Person#pragma mark - 公共方法#pragma mark 显示人员信息-(void)showMessage&#123;NSLog(@&quot;name=%@,age=%d&quot;,_name,_age);&#125;#pragma mark 设置人员账户-(void)setAccount:(Account *)account&#123; _account=account; 添加对Account的监听 [self.account addObserver:self forKeyPath:@&quot;balance&quot; options:NSKeyValueObservingOptionNew context:nil];&#125;#pragma mark - 覆盖方法#pragma mark 重写observeValueForKeyPath方法，当账户余额变化后此处获得通知-(void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context&#123; if([keyPath isEqualToString:@&quot;balance&quot;])&#123;//这里只处理balance属性 NSLog(@&quot;keyPath=%@,object=%@,newValue=%.2f,context=%@&quot;,keyPath,object,[[change objectForKey:@&quot;new&quot;] floatValue],context); &#125;&#125;#pragma mark 重写销毁方法-(void)dealloc&#123; [self.account removeObserver:self forKeyPath:@&quot;balance&quot;]; 移除监听[super dealloc]; 注意启用了ARC，此处不需要调用&#125;@end#import &lt;Foundation/Foundation.h&gt;#import &quot;Person.h&quot;#import &quot;Account.h&quot;int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; Person *person1=[[Person alloc]init]; person1.name=@&quot;Kenshin&quot;; Account *account1=[[Account alloc]init]; account1.balance=100000000.0; person1.account=account1;account1.balance=200000000.0; 注意执行到这一步会触发监听器回调函数observeValueForKeyPath: ofObject: change: context:结果：keyPath=balance,object=&lt;Account: 0x100103aa0&gt;,newValue=200000000.00,context=(null) &#125; return 0;&#125; 在上面的代码中我们在给人员分配账户时给账户的balance属性添加了监听，并且在监听回调方法中输出了监听到的信息，同时在对象销毁时移除监听，这就构成了一个典型的KVO应用。","tags":[{"name":"iOS学习","slug":"iOS学习","permalink":"http://binngirl.com/tags/iOS学习/"}]}]